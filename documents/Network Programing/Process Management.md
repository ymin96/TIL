# Process Management

> 프로세스의 생성과 좀비 프로세스의 제거방법을 알아본다.

<br>

프로세스가 무엇인가에 대한 설명은 다른 포스팅에 작성해 두었으니 자세한 설명은 생략하고 일단은 프로세스가**"메모리 공간을 차지한 상태에서 실행중인 프로그램"** 이란것만 알아두자.

<br>

### fork 함수호출을 통한 프로세스의 생성

프로세스 생성에는 몇 가지 방법이 있다. 그러나 여기선 멀티프로세스 기반 서버 구현에 사용되는 fork 함수에 대해 설명하겠다.

```c
#include <unistd.h>

pid_t fork(void);
> 성공 시 프로세스 ID, 실패 시 -1 반환
```

fork 함수는 호출한 프로세스의 복사본을 생성한다. 즉, 전혀 새로운 다른 프로그램을 바탕으로 프로세스를 생성하는 것이 아니라 이미 실행중인, fork 함수를 호출한 프로세스를 복사하는 것이다. 그리고는 두 프로세스 모두 fork 함수의 호출 이후 문장을 실행하게 된다. 그런데 완전히 동일한 프로세스로, 메모리 영역까지 동일하게 복사하기 때문에 이후의 프로그램 흐르므은 fork 함수의 반환 값을 기준으로 나뉘도록 프로그래밍을 해야 한다. 즉, fork 함수의 다음 특징을 이용해서 프로그램의 흐름을 구분해야 한다.

* 부모 프로세스 - fork 함수의 반환 값은 자식 프로세스의 ID
* 자식 프로세스 - fork 함수의 반환 값은 0

여기서 '부모 프로세스(Parent Process)'란 원본 프로세스. 즉, fork 함수를 호출한 주체가 된다. 반면 '자식 프로세스(Child Process)'는 부모 프로세스의 fork 함수 호출을 통해서 복사된 프로세스를 의미한다.

<br>

<br>

### 프로세스 &#38; 좀비(Zombie) 프로세스

파일은 여는 것 못지않게 닫는 것이 중요하다. 마찬가지로 프로세스도 생성 못지않게 소멸이 중요하다. 만약에 프로세스를 대충 닫는다면 좀비 프로세스가 될지 모른다.

#### 좀비(Zombie) 프로세스

프로세스가 생성되고 나서 할 일을 다 하면(main 함수의 실행을 완료하면) 사라져야 하는데 사라지지 않고 좀비가 되어 시스템의 중요한 리소스를 차지하기도 한다. 이 상태에 있는 프로세스를 가리켜 `좀비 프로세스`라 하는데, 이는 시스템에 부담을 주는 원인이 되기도 한다.

<br>

#### 좀비 프로세스의 생성이유

좀비 프로세스의 생성을 막기에 앞서 좀비 프로세스의 생성 이유를 먼저 살펴보자. fork 함수의 호출로 생성된 자식 프로세스가 종료되는 상황 두 가지를 예로 들면 다음과 같다.

* 인자를 전달하면서 exit를 호출하는 경우
* main 함수에서 return 문을 실행하면서 값을 반환하는 경우

exit 함수로 전달되는 인자 값과 main 함수의 return 문에 의해 반환되는 값 모두 운영체제로 전달된다. 그리고 운영체제는 이 값이 자식 프로세스를 생성한 부모 프로세스에게 전달될 때까지 자식 프로세스를 소멸시키지 않는데, 바로 이 상황에 놓여있는 프로세스를 가리켜 좀비 프로세스라 한다. 

이 좀비 프로세스는 해당 자식 프로세스를 생성한 부모 프로세스에게 exit 함수의 인자 값이나 return 문의 반환값이 전달되어야 소멸한다. 그렇다면 어떻게 부모 프로세스에게 값을 전달할까? 부모 프로세스의 함수호출이 있어야 운영체제는 값을 전달해 준다. 이제부터 이 함수를 알아보도록 하자.

<br>

#### 좀비 프로세스의 소멸1: wait 함수의 사용

```c
#include <sys/wait.h>

pid_t wait(int *statloc);
> 성공 시 종료된 자식 프로세스의 ID, 실패 시 -1 반환
```

위 함수가 호출되었을 때, 이미 종료된 자식 프로세스가 있다면, 자식 프로세스가 종료되면서 전달한 값이 매개변수로 전달된 주소의 변수에 저장된다. 그런데 이 변수에 저장되는 값에는 자식 프로세스가 종료되면서 전달한 값 이외에도 다른 정보가 함께 포함되어 있으니, 다음 메크로 함수를 통해서 값의 분리 과정을 거쳐야 한다.

* **WIFEXITED -** 자식 프로세스가 정상 종료한 경우 '참(True)'을 반환한다.
* **WEXITSTATUS -** 자식 프로세스의 전달 값을 반환한다.

즉, wait 함수의 인자로 변수 status의 주소 값이 전달되었다면, wait 함수의 호출 이후에는 다음과 같은 유형의 코드를 구성해야 한다.

```c
if(WIFEXITED(status)){
	puts("Normal termination!");
	printf("Child pass num: %d", WEXITSTATUS(status));
}
```

이 wait 함수는 호출된 시점에서 종료된 자식 프로세스가 없다면, 임의의 자식 프로세스가 종료될 때까지 블로킹(Blocking) 상태에 놓인다는 특징이 있다. 때문에 함수의 호출에 주의해야 한다.

<br>

#### 좀비 프로세스의 소멸2: waitpid 함수의 사용

wait 함수의 블로킹이 문제가 된다면 waitpid 함수의 호출을 고려하면 된다. 이는 좀비 프로세스의 생성을 막는 두 번째 방법이자 블로킹 문제의 해결책이기도 하다.

```c
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statloc, int options);
> 성공 시 종료된 자식 프로세스의 ID(또는 0), 실패 시 -1 반환
```

* **pid -** 종료를 확인하고자 하는 자식 프로세스의 ID 전달, 이를 대신해서 -1을 전달하면 wait 함수와 마찬가지로 임의의 자식 프로세스가 종료되기를 기다린다.
* **statloc -** wait 함수의 매개변수 statloc과 동일한 의미로 사용된다.
* **options -** 헤더파일 sys/wait.h 에 선언된 정수 WNOHANG을 인자로 전달하면, 종료된 자식 프로세스가 존재하지 않아도 블로킹 상태에 있지 않고, 0을 반환하면서 함수를 빠져 나온다.



