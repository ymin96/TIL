# Linux Epoll Guide

> select 보다 향상된 멀티플렉싱 구현 기법인 epoll 함수에 대해 알아본다.

<br>

select 는 오래 전에 개발된 멀티플렉싱 기법이다. 때문에 이를 이용하려면 아무리 프로그램의 성능을 최적화시킨다고 해도, 허용할 수 있는 동시접속자의 수가 백을 넘기 힘들다. 따라서 이에 대한 대안으로 리눅스 영역에서 주로 활용되는 epoll에 대해 알아보고자 한다.

<br>

### select 기반의 IO 멀티플렉싱이 느린 이유

select 기반의 가장 큰 문제점 두 가지는 다음과 같다.

* select 함수호출 이후에 항상 등장하는, 모든 파일 디스크립터를 대상으로 하는 반복문
* select 함수를 호출할 때마다 인자로 매번 전달해야 하는 관찰대상에 대한 정보들

select 함수는 기본적으로 운영체제에 의해 기능의 완성되는 함수이다. 근데 여기서 관찰대상의 정보들을 매번 운영체제에게 전달해주는 작업은 프로그램에 많은 부담이 따르는 일이다. 그리고 이는 코드의 개선을 통해서 덜 수 있는 유형의 부담이 아니기 때문에 성능에 치명적인 약점이 될 수 있다. 따라서 이러한 select 함수의 단점은 다음과 같은 방식으로 해결해야 한다.

**"운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고서, 관찰대상의 범위, 또는 내용에 변경이 있을 때 변경 사항만 알려주도록 하자."**

이렇게 되면 select 함수를 호출할 때마다 관찰대상에 대한 정보를 매번 운영체제에게 전달할 필요가 없다. 단, 이는 운영체제가 이러한 방식을 지원해야 한다. 리눅스는 이를 epoll 함수를 통해 지원하고 윈도우에선 IOCP를 쓴다.

<br>
<br>

### epoll의 구현에 필요한 함수와 구조체

select 함수의 단점을 극복한 epoll에는 다음의 장점이 있다. 이는 앞서 말한 select 함수의 단점에 상반된 특징이기도 하다. 

* 상태변화의 확인을 위한, 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없다.
* select 함수에 대응하는 epoll_wait 함수호출 시, 관찰대상의 정보를 매번 전달할 필요가 없다.

그럼 이제부터 epoll 기반의 서버구현에 필요한 세 가지 함수를 소개하겠다.

* **epoll_create -** epoll 파일 디스크립터 저장소 생성
* **epoll_ctl -** 저장소에 파일 디스크립터 등록 및 삭제
* **epoll_wait -** select 함수와 마찬가지로 파일 디스크립터의 변화를 대기한다.

epoll 은 관찰대상인 파일 디스크립터의 저장을 운영체제가 담당한다. 때문에 파일 디스크립터의 저장을 위한 저장소의 생성을 운영체제에게 요청해야 하는데, 이 때 사용되는 함수가 epoll_create이다.

그리고 epoll_ctl을 통해서 관찰대상인 파일 디스크립터를 추가, 삭제 할 수 있다. 마지막으로 epoll_wait를 통해서 파일 디스크립터의 변화를 대기한다. 그리고 상태변화가 일어나면 다음 구조체 epoll_event를 기반으로 상태변화가 발생한(이벤트가 발생한) 파일 디스크립터가 별도로 묶인다.

```c
struct epoll_event{
	__uint32_t events;
	epoll_data_t data;
}

typedef union epoll_data{
	void *ptr;
	int fd;
	__uint32_t u32;
	__uint64_t u64;
}epoll_data_t;
```

위의 구조체 epoll_event 기반의 배열을 넉넉한 길이로 선언해서 epoll_wait 함수호출 시 인자로 전달하면, 상태변화가 발생한 파일 디스크립터의 정보가 이 배열에 별도로 묶이기 때문에 select 함수에서 보인, 전체 파일 디스크립터를 대상으로 하는 반복문은 불필요하다.

<br>

#### epoll_create

```c
#include <sys/epoll.h>

int epoll_create(int size);
> 성공 시 epoll 파일 디스크립터, 실패 시 -1 반환
```

* **size -** epoll 인스턴스의 크기정보.

epoll_create 함수호출시 생성되는 파일 디스크립터의 저장소를 가리켜 `epoll 인스턴스` 라 한다. 그리고 매개변수 size를 통해서 전달되는 값은 epoll 인스턴스의 크기를 결정하는 정보로 사용된다. 하지만 이 값은 단지 운영체제에 전달하는 힌트에 지나지 않는다. 인자로 전달된 크기의 epoll 인스턴스가 생성되는 것이 아니라, epoll 인스턴스의 크기를 결정하는데 있어서 참고로만 사용된다.

그리고 epoll_create 함수호출에 의해서 생성되는 리소스는 소켓과 마찬가지로 운영체제에 의해서 관리가 된다. 따라서 이 함수는 소켓이 생성될 때와 마찬가지로 파일 디스크립터를 반환한다. 즉, 소멸 시에는 다른 파일 디스크립터와 마찬가지로 close 함수를 통한 종료의 과정을 거쳐야 한다.

<br>

#### epoll_ctl

epoll 인스턴스 생성 후에는 이곳에 관찰대상이 되는 파일 디스크립터를 등록해야 하는데, 이 때 사용하는 함수가 epoll_ctl이다.

```c
#include <sys/epoll.h>

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
> 성공 시 0, 실패 시 -1 반환
```

* **epfd -** 관찰대상을 등록할 epoll 인스턴스의 파일 디스크립터.
* **op -** 관찰대상의 추가, 삭제 또는 변경여부 지정.
* **fd -** 등록할 관찰대상의 파일 디스크립터.
* **event -** 관찰대상의 관찰 이벤트 유형.

먼저 epoll_ctl의 두 번째 인자로 전달 가능한 상수와 그 의미를 정리해 보겠다.

---

* **EPOLL_CTL_ADD -** 파일 디스크립터를 epoll 인스턴스에 등록한다.
* **EPOLL_CTL_DEL -** 파일 디스크립터를 epoll 인스턴스에서 삭제한다.
* **EPOLL_CTL_MOD -** 등록된 파일 디스크립터의 이벤트 발생상황을 변경한다.

---

여기서 epoll_ctl의 두 번째 인자로 EPOLL_CTL_DEL이 전달되면, 네 번째 인자로는 NULL 이 전달되야 한다. 

그럼 이제 별도로 설명이 필요한 네 번째 전달인자에 대해서 설명하겠다. 네 번째 전달인자의 자료형은 앞서 설명한 구조체 epoll_event의 포인터이다.

앞서 말했듯이 구조체 epoll_event는 이벤트가 발생한 파일 디스크립터를 묶는 용도로 사용된다. 하지만 파일 디스크립터를 epoll 인스턴스에 등록할 때, 이벤트의 유형을 등록하는 용도로도 사용된다. 문장을 통해서 이 구조체가 epoll_ctl 함수에 어떻게 활용되는지 설명하겠다.

```c
struct epoll_event event;
....
event.events = EPOLLIN;		// 수신할 데이터가 존재하는 상황(이벤트) 발생시
event.dat.fd = sockfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &event);
....
```

위의 코드는 epoll 인스턴스인 epfd에 sockfd 를 등록하되, 수신할 데이터가 존재하는 상황에서 이벤트가 발생하도록 등록하는 방법을 보이고 있다. 그럼 이번에는 epoll_event의 멤버인 events에 저장 가능한 상수와 이벤트의 유형에 대해 정리해 보겠다.

---

* **EPOLLIN -** 수신할 데이터가 존재하는 상황
* **EPOLLOUT -** 출력버퍼가 비워져서 당장 데이터를 전송할 수 있는 상황
* **EPOLLPRI -** OOB 데이터가 수신된 상황
* **EPOLLRDHUP -** 연결이 종료되거나 Half-close가 진행된 상황, 이는 엣지 트리거 방시에서 유용하게 사용될 수 있다.
* **EPOLLERR -** 에러가 발생한 상황
* **EPOLLET -** 이벤트의 감지를 엣지 트리거 방식으로 동작시킨다.
* **EPOLLONESHOT -** 이벤트가 한번 감지되면, 해당 파일 디스크립터에서는 더 이상 이벤트를 발생시키지 않는다. 따라서 epoll_ctl 함수의 두 번째 인자로 EPOLL_CTL_MOD을 전달해서 이벤트를 재설정해야 한다.

---

위의 상수들은 비트 OR 연산자를 이용해서 둘 이상을 함께 등록할 수 있다. 그리고 이 중에서 `엣지 트리거`라는 말이 나오는데, 이는 후에 별도로 설명하겠다.

<br>

#### epoll_wait

이제 마지막으로 select 함수에 해당하는 epoll_wait 함수를 소개할 차례이다. 기본적으로 이 함수가 epoll 관련 함수 중에서 가장 마지막에 호출된다.

```c
#include <sys/epoll.h>

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
> 성공 시 이벤트가 발생한 파일 디스크립터의 수, 실패 시 -1 반환
```

* **epfd -** 이벤트 발생의 관찰영역인 epoll 인스턴스의 파일 디스크립터.
* **events -** 이벤트가 발생한 파일 디스크립터가 채워질 버퍼의 주소 값.
* **maxevents -** 두 번째 인자로 전달된 주소 값의 버퍼에 등록 가능한 최대 이벤트 수.
* **timeout -** 1/1000초 단위의 대기시간, -1 전달 시, 이벤트가 발생할 때까지 무한 대기

이 함수의 호출방식은 다음과 같다. 여기서는 두 번째 인자로 전달되는 주소 값의 버퍼를 동적으로 할당해야 한다는 점만 주목하면 된다.

```c
int event_cnt;
struct epoll_event *ep_events;
....
ep_events = malloc(sizeof(struct epoll_event)*EPOLL_SIZE); // EPOLL_SIZE는 매크로 상수 값
....
event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1);
....
```

함수호출 후에는 이벤트가 발생한 파일 디스크립터의 수가 반환되고, 두 번째 인자로 전달된 주소 값의 버퍼에는 이벤트가 발생한 파일 디스크립터의 정보가 별도로 묶이기 때문에 select 방식에서 보인 전체 파일디스크립터를 대상하는 반복문은 불필요하다.

