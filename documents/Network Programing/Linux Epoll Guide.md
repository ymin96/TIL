# Linux Epoll Guide

> select 보다 향상된 멀티플렉싱 구현 기법인 epoll 함수에 대해 알아본다.

<br>

select 는 오래 전에 개발된 멀티플렉싱 기법이다. 때문에 이를 이용하려면 아무리 프로그램의 성능을 최적화시킨다고 해도, 허용할 수 있는 동시접속자의 수가 백을 넘기 힘들다. 따라서 이에 대한 대안으로 리눅스 영역에서 주로 활용되는 epoll에 대해 알아보고자 한다.

<br>

### select 기반의 IO 멀티플렉싱이 느린 이유

select 기반의 가장 큰 문제점 두 가지는 다음과 같다.

* select 함수호출 이후에 항상 등장하는, 모든 파일 디스크립터를 대상으로 하는 반복문
* select 함수를 호출할 때마다 인자로 매번 전달해야 하는 관찰대상에 대한 정보들

select 함수는 기본적으로 운영체제에 의해 기능의 완성되는 함수이다. 근데 여기서 관찰대상의 정보들을 매번 운영체제에게 전달해주는 작업은 프로그램에 많은 부담이 따르는 일이다. 그리고 이는 코드의 개선을 통해서 덜 수 있는 유형의 부담이 아니기 때문에 성능에 치명적인 약점이 될 수 있다. 따라서 이러한 select 함수의 단점은 다음과 같은 방식으로 해결해야 한다.

**"운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고서, 관찰대상의 범위, 또는 내용에 변경이 있을 때 변경 사항만 알려주도록 하자."**

이렇게 되면 select 함수를 호출할 때마다 관찰대상에 대한 정보를 매번 운영체제에게 전달할 필요가 없다. 단, 이는 운영체제가 이러한 방식을 지원해야 한다. 리눅스는 이를 epoll 함수를 통해 지원하고 윈도우에선 IOCP를 쓴다.

<br>
<br>

### epoll의 구현에 필요한 함수와 구조체

select 함수의 단점을 극복한 epoll에는 다음의 장점이 있다. 이는 앞서 말한 select 함수의 단점에 상반된 특징이기도 하다. 

* 상태변화의 확인을 위한, 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없다.
* select 함수에 대응하는 epoll_wait 함수호출 시, 관찰대상의 정보를 매번 전달할 필요가 없다.

그럼 이제부터 epoll 기반의 서버구현에 필요한 세 가지 함수를 소개하겠다.

* **epoll_create -** epoll 파일 디스크립터 저장소 생성
* **epoll_ctl -** 저장소에 파일 디스크립터 등록 및 삭제
* **epoll_wait -** select 함수와 마찬가지로 파일 디스크립터의 변화를 대기한다.

epoll 은 관찰대상인 파일 디스크립터의 저장을 운영체제가 담당한다. 때문에 파일 디스크립터의 저장을 위한 저장소의 생성을 운영체제에게 요청해야 하는데, 이 때 사용되는 함수가 epoll_create이다.

그리고 epoll_ctl을 통해서 관찰대상인 파일 디스크립터를 추가, 삭제 할 수 있다. 마지막으로 epoll_wait를 통해서 파일 디스크립터의 변화를 대기한다. 그리고 상태변화가 일어나면 다음 구조체 epoll_event를 기반으로 상태변화가 발생한(이벤트가 발생한) 파일 디스크립터가 별도로 묶인다.

```c
struct epoll_event{
	__uint32_t events;
	epoll_data_t data;
}

typedef union epoll_data{
	void *ptr;
	int fd;
	__uint32_t u32;
	__uint64_t u64;
}epoll_data_t;
```

위의 구조체 epoll_event 기반의 배열을 넉넉한 길이로 선언해서 epoll_wait 함수호출 시 인자로 전달하면, 상태변화가 발생한 파일 디스크립터의 정보가 이 배열에 별도로 묶이기 때문에 select 함수에서 보인, 전체 파일 디스크립터를 대상으로 하는 반복문은 불필요하다.

<br>

#### epoll_create

```c
#include <sys/epoll.h>

int epoll_create(int size);
> 성공 시 epoll 파일 디스크립터, 실패 시 -1 반환
```

* **size -** epoll 인스턴스의 크기정보.

epoll_create 함수호출시 생성되는 파일 디스크립터의 저장소를 가리켜 `epoll 인스턴스` 라 한다. 그리고 매개변수 size를 통해서 전달되는 값은 epoll 인스턴스의 크기를 결정하는 정보로 사용된다. 하지만 이 값은 단지 운영체제에 전달하는 힌트에 지나지 않는다. 인자로 전달된 크기의 epoll 인스턴스가 생성되는 것이 아니라, epoll 인스턴스의 크기를 결정하는데 있어서 참고로만 사용된다.

그리고 epoll_create 함수호출에 의해서 생성되는 리소스는 소켓과 마찬가지로 운영체제에 의해서 관리가 된다. 따라서 이 함수는 소켓이 생성될 때와 마찬가지로 파일 디스크립터를 반환한다. 즉, 소멸 시에는 다른 파일 디스크립터와 마찬가지로 close 함수를 통한 종료의 과정을 거쳐야 한다.

<br>

#### epoll_ctl

epoll 인스턴스 생성 후에는 이곳에 관찰대상이 되는 파일 디스크립터를 등록해야 하는데, 이 때 사용하는 함수가 epoll_ctl이다.

```c
#include <sys/epoll.h>

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
> 성공 시 0, 실패 시 -1 반환
```

* **epfd -** 관찰대상을 등록할 epoll 인스턴스의 파일 디스크립터.
* **op -** 관찰대상의 추가, 삭제 또는 변경여부 지정.
* **fd -** 등록할 관찰대상의 파일 디스크립터.
* **event -** 관찰대상의 관찰 이벤트 유형.

먼저 epoll_ctl의 두 번째 인자로 전달 가능한 상수와 그 의미를 정리해 보겠다.

---

* **EPOLL_CTL_ADD -** 파일 디스크립터를 epoll 인스턴스에 등록한다.
* **EPOLL_CTL_DEL -** 파일 디스크립터를 epoll 인스턴스에서 삭제한다.
* **EPOLL_CTL_MOD -** 등록된 파일 디스크립터의 이벤트 발생상황을 변경한다.

---

여기서 epoll_ctl의 두 번째 인자로 EPOLL_CTL_DEL이 전달되면, 네 번째 인자로는 NULL 이 전달되야 한다. 

그럼 이제 별도로 설명이 필요한 네 번째 전달인자에 대해서 설명하겠다. 네 번째 전달인자의 자료형은 앞서 설명한 구조체 epoll_event의 포인터이다.

앞서 말했듯이 구조체 epoll_event는 이벤트가 발생한 파일 디스크립터를 묶는 용도로 사용된다. 하지만 파일 디스크립터를 epoll 인스턴스에 등록할 때, 이벤트의 유형을 등록하는 용도로도 사용된다. 문장을 통해서 이 구조체가 epoll_ctl 함수에 어떻게 활용되는지 설명하겠다.

```c
struct epoll_event event;
....
event.events = EPOLLIN;		// 수신할 데이터가 존재하는 상황(이벤트) 발생시
event.dat.fd = sockfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &event);
....
```

위의 코드는 epoll 인스턴스인 epfd에 sockfd 를 등록하되, 수신할 데이터가 존재하는 상황에서 이벤트가 발생하도록 등록하는 방법을 보이고 있다. 그럼 이번에는 epoll_event의 멤버인 events에 저장 가능한 상수와 이벤트의 유형에 대해 정리해 보겠다.

---

* **EPOLLIN -** 수신할 데이터가 존재하는 상황
* **EPOLLOUT -** 출력버퍼가 비워져서 당장 데이터를 전송할 수 있는 상황
* **EPOLLPRI -** OOB 데이터가 수신된 상황
* **EPOLLRDHUP -** 연결이 종료되거나 Half-close가 진행된 상황, 이는 엣지 트리거 방시에서 유용하게 사용될 수 있다.
* **EPOLLERR -** 에러가 발생한 상황
* **EPOLLET -** 이벤트의 감지를 엣지 트리거 방식으로 동작시킨다.
* **EPOLLONESHOT -** 이벤트가 한번 감지되면, 해당 파일 디스크립터에서는 더 이상 이벤트를 발생시키지 않는다. 따라서 epoll_ctl 함수의 두 번째 인자로 EPOLL_CTL_MOD을 전달해서 이벤트를 재설정해야 한다.

---

위의 상수들은 비트 OR 연산자를 이용해서 둘 이상을 함께 등록할 수 있다. 그리고 이 중에서 `엣지 트리거`라는 말이 나오는데, 이는 후에 별도로 설명하겠다.

<br>

#### epoll_wait

이제 마지막으로 select 함수에 해당하는 epoll_wait 함수를 소개할 차례이다. 기본적으로 이 함수가 epoll 관련 함수 중에서 가장 마지막에 호출된다.

```c
#include <sys/epoll.h>

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
> 성공 시 이벤트가 발생한 파일 디스크립터의 수, 실패 시 -1 반환
```

* **epfd -** 이벤트 발생의 관찰영역인 epoll 인스턴스의 파일 디스크립터.
* **events -** 이벤트가 발생한 파일 디스크립터가 채워질 버퍼의 주소 값.
* **maxevents -** 두 번째 인자로 전달된 주소 값의 버퍼에 등록 가능한 최대 이벤트 수.
* **timeout -** 1/1000초 단위의 대기시간, -1 전달 시, 이벤트가 발생할 때까지 무한 대기

이 함수의 호출방식은 다음과 같다. 여기서는 두 번째 인자로 전달되는 주소 값의 버퍼를 동적으로 할당해야 한다는 점만 주목하면 된다.

```c
int event_cnt;
struct epoll_event *ep_events;
....
ep_events = malloc(sizeof(struct epoll_event)*EPOLL_SIZE); // EPOLL_SIZE는 매크로 상수 값
....
event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1);
....
```

함수호출 후에는 이벤트가 발생한 파일 디스크립터의 수가 반환되고, 두 번째 인자로 전달된 주소 값의 버퍼에는 이벤트가 발생한 파일 디스크립터의 정보가 별도로 묶이기 때문에 select 방식에서 보인 전체 파일디스크립터를 대상하는 반복문은 불필요하다.

<br>

<br>

### Level,Edge Trigger

epoll을 알면서 레벨 트리거 방식과 엣지 트리거 방식의 차이를 알아야 epoll을 완전히 이해하는 것이다.

<br>

#### 레벨 트리거(Level Trriger)

**레벨 트리거 방식에서는 입력버퍼에 데이터가 남아있는 동안에 계속해서 이벤트가 등록된다.** 예를 들어 서버의 입력버퍼로 50바이트의 데이터가 수신되면, 일단 서버 측 운영체제는 이를 이벤트로 등록한다(변화가 발생한 파일 디스크립터로 등록한다). 그런데 서버 프로그램에서 20바이트를 수신해서 입력버퍼에 30바이트만 남는다면, 이 상황 역시 이벤트로 등록이 된다. 이렇듯 레벨 트리거 방식에서는 입력버퍼에 데이터가 남아있기만 해도 이 상황을 이벤트로 등록한다. 

<br>

#### 엣지 트리거(Edge Trriger)

**엣지 트리거는 입력버퍼로 데이터가 수신된 상황에서 한번만 이벤트가 등록된다.** 위의 레벨 트리거와 똑같은 상황이라고 가정하면 엣지 트리거에선 20바이트를 수신하고 30바이트가 버퍼에 남아있어도 더 이상 이벤트를 발생시키지 않는다.

<br>

#### 엣지 트리거 기반의 서버 구현을 위해서 알아야 할 것 두 가지

다음 두 가지는 엣지 트리거 기반의 서버 구현을 하는데 필수적으로 알아야 할 것이다.

1. 변수 errno을 이용한 오류의 원인을 확인하는 방법
2. 넌-블로킹(Non-blocking) IO를 위한 소켓의 특성을 변경하는 방법

일반적으로 리눅스에서 제공하는 소켓관련 함수는 -1을 반환함으로써 오류의 발생을 알린다. 따라서 오류가 발생했음을 인식할 수는 있으나, 이것만으로는 오류의 원인을 정확히 확인할 수 없다. 때문에 리눅스에서는 오류발생시 추가적인 정보의 제공을 위해서 다음의 변수를 전역으로 선언해 놓고 있다.

**int errno;**

이 변수의 접근을 위해서는 헤더파일 error.h를 포함해야 한다. 그럼 엣지 트리거 방식을 사용하는데 필요한 에러를 말하겠다.

**"read 함수는 입력버퍼가 비어서 더 이상 읽어 들일 데이터가 없을 때 -1을 반환하고, 이 때 errno에는 상수 EAGAIN가 저장된다."**

이번에는 소켓을 넌-블로킹 모드로 변경하는 방법을 설명하겠다. 리눅스에서는 파일의 특성을 변경 및 참조하는 다음 함수가 정의되어 있다.

```c
#include <fcntl.h>

int fcntl(int filedes, int cmd, . . .);
> 성공 시 매개변수 cmd에 따른 값, 실패 시 -1 반환
```

* **filedes -** 특성 변경의 대상이 되는 파일의 파일 디스크립터
* **cmd -** 함수호출의 목적에 해당하는 정보 전달.

위에서 보이듯이 fcntl 함수는 가변인자의 형태로 정의되어 있다. 그리고 두 번째 인자로 **F_GETFL**을 전달하면, 첫 번째 인자로 전달된 디스크립터에 설정되어 있는 특성정보를 int형으로 얻을 수 있으며, 반대로 **F_SETFL**을 인자로 전달해서 특성정보를 변경할 수도 있다. 따라서 파일을(소켓을) 넌-블로킹 모드로 변경하기 위해서는 다음의 두 문장을 실행하면 된다.

```c
int flag = fcntl(fd, F_GETFL, 0);
fcntl(fd, F_SETFL, flag|O_NONBLOCK);
```

첫 번째 문장을 통해서 기존에 설정되어 있던 특성정보를 얻어오고, 두 번째 문장에서는 여기에 넌-블로킹 입출력을 의미하는 O_NONBLOCK을 더해서 특성을 재설정해주고 있다. 이로서 read, write 함수호출 시에도 데이터의 유무에 상관없이 블로킹이 되지 않는 파일(소켓)이 만들어진다.

<br>

#### 레벨 트리거와 엣지 트리거의 차이

레벨 트리거와 엣지 트리거의 차이점은 이론적으로 보았지만 이정도만 가지고는 엣지 트리거가 레벨 트리거에 비해 지니는 장점을 이해하기 쉽지 않다. 그러나 엣지 트리거 방식을 이용하면 다음과 같은 형태의 구현이 가능하다.

**"데이터의 수신과 데이터가 처리되는 시점을 분리할 수 있다."**

이는 단순하지만 엣지 트리거의 장점을 매우 정확하고 강력하게 설명하고 있다. 이해를 돕기 위해 한가지 예를 들어보겠다.

* 서버는 클라이언트 A,B,C 로부터 각각 데이터를 수신한다.
* 서버는 수신한 데이터를 A,B,C 의 순으로 조합한다.
* 조합한 데이터는 임의의 호스트에게 전달한다.

위의 시나리오를 완성하기 위해서 다음과 같은 형태로만 흐름이 전개되면, 서버의 구현을 그리 어렵지 않다.

* 클라이언트 A, B, C가 순선대로 접속해서 데이터를 순서대로 서버에 전송한다.
* 데이터를 수신할 클라이언트는 클라이언트 A, B, C에 앞서 먼저 접속을 하고 대기한다.

그러나 현실적으로는 다음과 같은 상황이 변변히 일어난다. 즉, 다음의 상황이 보다 현실적이다.

* 클라이언트 C와 B는 서버로 데이터를 전송하고 있는데, A는 아직 연결조차 하지 않은 경우
* 클라이언트 A, B, C가 순서에 상관없이 데이터를 서버로 전송하는 경우
* 서버로 데이터가 전송되고 있는데, 정작 이 데이터를 수신할 클라이언트가 아직 연결되지 않은 경우

따라서 입력버퍼에 데이터가 수신된 상황임에도 불구하고(이벤트가 등록된 상황임에도 불구하고), 이를 읽어 들이고 처리하는 시점을 서버가 결정할 수 있도록 하는 것은 서버 구현이 엄청난 유연성을 제공한다.