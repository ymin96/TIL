# Shell Script

> 우분투에서 사용하는 bash/shell 에 대하여 알아본다.

<br>

셸은 사용자가 입력한 명령을 해석해 커널에게 전달하거나, 커널의 처리 결과를 사용자에게 전달하는 역할을 한다.

<br>

### 환경변수

셸에 설정된 환경 변수는 `echo $환경변수이름` 형식의 명령으로 확인할 수 있다. 환경 변수의 값을 변경하려면 `expert 환경변수=값` 형식을 실행한다. 그 이외의 환경 변수는 `printev` 명령을 실행하면 출력된다.

| 환경 변수 | 설명                      | 환경 변수    | 설명                           |
| --------- | ------------------------- | ------------ | ------------------------------ |
| HOME      | 현재 사용자의 홈 디렉터리 | PATH         | 실행 파일을 찾는 디렉터리 경로 |
| LANG      | 기본 지원되는 언어        | PWD          | 사용자의 현재 작업 디렉터리    |
| TERM      | 로그인 터미널 타입        | SHELL        | 로그인해서 사용하는 셸         |
| USER      | 현재 사용자의 이름        | DISPLAY      | X 디스플레이 이름              |
| COLUMNS   | 현재 터미널의 컬럼 수     | LINES        | 현재 터미널 라인 수            |
| PS1       | 1차 명령 프롬프트 변수    | PS2          | 2차 명령 프롬프트(대개는'>')   |
| BASH      | bash 셸의 경로            | BASH_VERSION | bash 버전                      |
| HISTFILE  | 히스토리 파일의 경로      | HISTSIZE     | 히스토리 파일에 저장되는 개수  |
| HOSTNAME  | 호스트이 이름             | USERNAME     | 현재 사용자 이름               |
| LOGNAME   | 로그인 이름               | LS_COLORS    | ls 명령의 확장사 색상 옵션     |
| MAIL      | 메일을 보관하는 경로      | OSTYPE       | 운영체제 타입                  |

<br>

<br>

## 셸 스크립트

셸 스크립트도 일반적인 프로그래밍 언어와 비슷하게 변수, 반복문, 제어문 등을 사용할 수 있다. 또한 별도로 컴파일하지 않고 텍스트 파일 형태로 셸에서 바로 실행할 수 있다. 

셸 스크립트의 첫 번째 행에는 `#!/bin/sh` 을 꼭 써줘야 한다.

<br>

### sh 명령으로 실행

`sh 스크립트파일` 명령으로 실행할 수 있따. 셸 스크립트 파일의 속성을 변경할 필요가 없다는 장점이 있다.

### '실행가능' 속성으로 변경한 후 실행

`chmod +x 파일명` 명령으로 파일에 '실행 가능' 속성을 추가하면 `./스크립트파일` 명령으로 실행할 수 있다.

<br>

<br>

 ### 변수

셸 스크립트의 구조는 변경할 필요가 없는데 설정해야 하는 값이 상황에 따라 다르다면 변수에 필요한 값을 계속 바꿔가는 방법으로 프로그래밍해 다양한 상황에 대처할 수 있다.

<br>

#### 변수의 기본

* 셸 스크립트에서는 변수를 사용하기 전에 미리 선언하지 않으며, 처음 변수에 값이 할당되면 자동으로 변수가 생성된다.
* 변수에 넣는 모든 값은 문자열로 취급된다. 즉, 숫자를 넣어도 문자로 취급한다.
* 변수 이름은 대소문자를 구분한다. 즉 $aa 라는 변수 이름과 $AA라는 변수 이름은 다르다.
* 변수를 대입할때 `=` 좌우에는 공백이 없어야 한다.

<br>

#### 변수의 입력과 출력

`read 변수명` 명령으로 사용자 키보드값을 입력받을수 있다. 변수의 출력은 `echo $변수명`  명령으로 가능하다.

<br>

#### 숫자 계산

변수에 들어 있는 값에 `+, -, *, /` 등의 연산을 하려면 `expr` 키워드를 사용하면 된다. 단, 수식과 함께 꼭 키보드 숫자 1 왼쪽에 있는 역따옴표(`) 로 묶어줘야 한다. 수식에 괄호를 사용하려면 그 앞에 꼭 역슬래시를 붙여줘야한다. 또 곱하기(*)기호도 예외적으로 앞에 역슬래시 기호를 붙여줘야 한다.

```sh
num1=`expr 100 + 200`
num2=`expr \( 100 + 200 \) /10 /* 2`
echo num1		-> 300
echo num2		-> 60
```

<br>

#### 파라미터 변수

파라미터 변수는 **$0, $1, $2** 등의 형태를 갖는다. 이는 실행하는 명령의 부분 하나하나를 변수로 지정한다는 의미다.

예를 들어 `apt-get -y install gftp` 명령을 실행한다고 가정하면, 파라미터 변수는 다음과 같이 지정할 수 있다.

| 명령          | apt-get | -y   | install | gftp |
| ------------- | ------- | ---- | ------- | ---- |
| 파라미터 변수 | $0      | $1   | $2      | $3   |

 명령 전체의 파라미터 변수는 $* 로 표현한다.

```sh 
#!/bin/sh
echo "실행파일 이름은 <$0> 이다"
echo "첫번째 파라미터는 <$1>이고, 두번째 파라미터는 <$2>다"
echo "전체 파라미터는 <$*>다"
exit 0
```

![Shell_Script1](../img/Linux/Shell_Script1.PNG)

<br>

<br>

### if 문과 case 문

<br>

#### if~else 문

if~else 문의 형식은 다음과 같다.

```sh
if [ 조건 ]
then
	참일 경우 실행
else
	거짓일 경우 실행
fi
```

주의할 점은 '[ 조건 ]' 사이의 각 단어에는 모두 공백이 있어야 한다는 것이다. 위 형식에서 else는 생략 가능하다.

<br>

#### 조건문에 들어가는 비교 연산자

조건문에 들어가는 비교 연산자에는 문자열 비교 연산자와 산술 연산자가 있다. 

**문자열 비교 연산자**

| 문자열 비교            | 결과                                 |
| ---------------------- | ------------------------------------ |
| "문자열1" = "문자열2"  | 두 문자열이 같으면 참                |
| "문자열1" != "문자열2" | 두 문자열이 같지 않으면 참           |
| -n "문자열"            | 문자열이 NULL(빈 문자열)이 아니면 참 |
| -z "문자열"            | 문자열이 NULL(빈 문자열)이면 참      |

**산술 비교 연산자**

| 산술 비교       | 결과                                |
| --------------- | ----------------------------------- |
| 수식1 -eq 수식2 | 두 수식(또는 변수)이 같으면 참      |
| 수식1 -ne 수식2 | 두 수식(또는 변수)이 같지 않으면 참 |
| 수식1 -gt 수식2 | 수식1이 크다면 참                   |
| 수식1 -ge 수식2 | 수식1이 크거나 같으면 참            |
| 수식1 -lt 수식2 | 수식1이 작으면 참                   |
| 수식1 -le 수식2 | 수식1이 작거나 같으면 참            |
| !수식           | 수식이 거짓이라면 참                |

<br>

#### 파일과 관련된 조건

| 파일 조건   | 결과                              |
| ----------- | --------------------------------- |
| -d 파일이름 | 파일이 디렉터리면 참              |
| -e 파일이름 | 파일이 존재하면 참                |
| -f 파일이름 | 파일이 일반 파일이면 참           |
| -g 파일이름 | 파일에 set-group-id가 설정되면 참 |
| -r 파일이름 | 파일이 읽기 가능이면 참           |
| -s 파일이름 | 파일 크기가 0이 아니면 참         |
| -u 파일이름 | 파일에 set-user-id가 설정되면 참  |
| -w 파일이름 | 파일이 쓰기 가능 상태이면 참      |
| -x 파일이름 | 파일이 실행 가능 상태이면 참      |

<br>

#### case~esac 문

if문은 참과 거짓이라는 두 가지 경우면 사용할 수 있다. 그런데 여러 가지 경우의 수가 있다면  if문을 중복해서 사용해야 하므로 구문이 복잡해진다. 이때 사용하는 것이 case문이다. 이를 `다중 분기` 라 한다.

```sh
#!/bin/sh
echo "리눅스가 재미있나요?(yes / no)"
read answer			-> answer 변수에 입력한 값을 받는다.
case $answer in
	yes | y | Y | Yes | YES)	-> 입력된 값이 yes,y,Y,Yes,YES 중 하나면 6~7행을 실행한다.
		echo "다행입니다."		-> 실행할 구문이 더 있으므로 끝에 ;;를 붙이지 않는다.
		echo "더욱 열심히 하세요 ^^";;	-> 실행할 구문이 더 없으면 끝에 ;;를 붙인다.
	[nN]*)		-> 앞에 n 또는 N 이 들어가는 모든 단어를 다 인정해준다는 의미다.
		echo "안타깝네요 ㅠㅠ";;
	*)		-> 그 외에 것들이 모두 해당한다.
		echo "yes 아니면 no만 입력했어야죠"
		exit 1;;	-> 정상적인 종료가 아니므로 exit 1로 종료한다.
esac
exit 0
```

![Shell_Script2](../img/Linux/Shell_Script2.PNG)

<br>

#### AND, OR 관계 연산자

조건문에서는 and 와 or 의 의미를 갖는 관계 연산자를 사용할 수 있다. and 는 `-a 또는 &&`를 사용하며, or은 `-o 또는 ||` 를 사용한다. -a 나 -o는 테스트문([ ])안에서 사용할 수 있는데, 이때 괄호등의 특수 문자 앞에는 역슬래시를 붙여줘야 한다.

```sh
#!/bin/sh
echo "보고 싶은 파일명을 입력하세요."
read fname
if [ -f $fname ] && [ -s $fname ] ; then
	head -5 $fname
else
	echo "파일이 없거나, 크기가 0입니다."
if
exit 0
```

입력한 파일 이름이 일반 파일(-f)이고, 크기가 0이 아니라면(-s) `head -5 $fname` 명령을 실행한다. 또, 이 구문은 `if [\(-f $fname\) -a \(-s $fname\)] ; then` 과 동일하다.

<br>

<br>

### 반복문





