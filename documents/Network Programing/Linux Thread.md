# Linux Thread

> 리눅스에서 쓰레드의 사용방법에 대해 알아본다.

<br>

### 쓰레드의 생성, 종료 및 실행

POSIX란 `Potable Operating System Interface for Computer Environment` 의 약자로써 UNIX 계열 운영체제간에 이식성을 높이기 위한 표준 API 규격을 뜻한다. 그리고 이어서 설명하는 쓰레드의 생성방법은 POSIX에 정의된 표준을 근거로 한다. 때문에 리눅스뿐만 아니라, 유닉스 계열의 운영체제에서도 대부분 적용 가능하다.

<br>

#### 쓰레드의 생성

쓰레드는 별도의 실행흐름을 갖기 때문에 쓰레드만의 main 함수를 별도로 정의해야 한다. 그리고 이 함수를 시작으로 별도의 실행흐름을 형성해 줄 것을 운영체제에게 요청해야 하는데, 이를 목적으로 호출하는 함수는 다음과 같다.

```c
#include <pthread.h>

int pthread_create(
	pthread_t *restrict thread, const pthread_attr_t *restrict attr,
	void *(*start_routine)(void*), void *restrict arg
);
> 성공 시 0, 실패 시 0 이외의 값 반환
```

* **thread -** 생성할 쓰레드의 ID 저장을 위한 변수의 주소 값 전달, 참고로 쓰레드는 프로세스와 마찬가지로 쓰레드의 구분을 위한 ID가 부여된다.
* **attr -** 쓰레드에 부여할 특성 정보의 전달을 위한 매개변수, NULL 전달 시 기본적인 특성의 쓰레드가 생성된다.
* **start_routine -** 쓰레드의 main 함수 역할을 하는, 별도 실행흐름의 시작이 되는 함수의 주소값(함수 포인터) 전달.
* **arg -** 세 번째 인자를 통해 등록된 함수가 호출될 때 전달할 인자의 정보를 담고 있는 변수의 주소 값 전달.

쓰레드 관련코드는 컴파일 시 **-lpthread** 옵선을 추가해서 쓰레드 라이브러리의 링크를 별도로 지시해야 한다. 그래야 헤더파일 pthread.h 에 선언된 함수들을 호출할 수 있다. 

<br>

#### 쓰레드의 종료

리눅스의 쓰레드는 처음 호출하는, 쓰레드의 main 함수를 반환했다고 해서 자동으로 소멸되지 않는다. 때문에 다음 두 가지 방법중 하나를 택해서 쓰레드의 소멸을 직접적으로 명시해야 한다. 그렇지 않으면 쓰레드에 의해서 할당된 메모리 공간이 계속해서 남아있게 된다.

1. pthread_join 함수의 호출
2. pthread_detach 함수의 호출

먼저 pthread_join 함수부터 알아보자.

```c
#include <pthread.h>

int pthread_join(pthread_t thread, void **status);
> 성공 시 0, 실패 시 0 이외의 값 반환
```

* **thread -** 이 매개변수에 전달되는 ID의 쓰레드가 종료될 때까지 함수는 반환하지 않는다.
* **status -** 쓰레드의 main 함수가 반환하는 값이 저장될 포인터 변수의 주소 값을 전달한다.

위 함수는 첫 번째 인자로 전달되는 ID의 쓰레드가 종료될 때까지, 이 함수를 호출한 프로세스(또는 쓰레드)를 대기상태에 둔다. 뿐만 아니라, 쓰레드의 main 함수가 반환하는 값까지 엊을 수 있다. 단 프로세스를 블로킹 상태로 만드는 것은 단점이 될 수도 있다. 따라서 일반적으로는 pthread_detach 함수를 통해서 쓰레드의 소멸을 유도한다.

```c
#include <pthread.h>

int pthread_detach(pthread_t thread);
> 성공 시 0, 실패 시 0 이외의 값 반환
```

* **thread -** 종료와 동시에 소멸시킬 쓰레드의 ID정보 전달.

위 함수를 호출했다고 해서 종료되지 않은 쓰레드가 종료되거나, 블로킹 상태에 놓이지는 않는다. 따라서 이 함수를 통해서 쓰레드에게 할당된 메모리의 소멸을 유도할 수 있다. 그리고 이 함수가 호출된 이후에는 해당 쓰레드를 대상으로 pthread_join 함수의 호출이 불가능하니, 이점에 주의해야 한다. 

<br>

#### 임계영역 내에서 호출이 가능한 함수

임계영역의 문제와 관련해서 함수는 다음 두 가지 종류로 구분된다.

* 쓰레드에 안전한 함수(Thread-safe function)
* 쓰레드에 불안전한 함수(Thread-unsafe function)

여기서 Thread-safe function은 임계영역이 없는 함수가 아니다. 죽, 쓰레드에 안전한 함수도 임계영역이 존재할 수 있다. 다만 이 영역을 둘 이상의 쓰레드가 동시에 접근해도 문제를 일으키지 않도록 적절한 조치가 이뤄져 있어서 쓰레드에 안전한 함수로 구분될 수 있는 것이다.

다행히 기본적으로 제공되는 대부분의 표준함수들은 쓰레드에 안전하다. 그러나 그보다 더 다행인 것은 쓰레드에 안전한 함수와 불안전한 함수의 구분을 프로그래머가 직접 할 필요가 없다는데 있다. 왜냐하면 쓰레드에 불안전한 함수가 정의되어 있는 경우, 같은 기능을 갖는 쓰레드에 안전함 함수가 정의되어 있기 때문이다.

다음과 같은 방법을 통해서 Thread-unsafe function을 자동으로 Thread-safe function으로 만들어줄 수 있다. 

**"헤더파일 선언 이전에 매크로 _REENTRANT를 정의한다."**

그리고 위의 매크로 정의를 위해서 굳이 소스코드에 #define 문장을 추가할 필요는 없다. 다음과 같이 컴파일 시         **-D_REENTRANT**의 옵션을 추가하는 방식으로도 매크로를 정의할 수 있기 때문이다.

**gcc -D_REENTRANT example.c -o example -lpthread**

따라서 쓰레드 관련 코드가 삽입되어 있는 코드를 컴파일 할 때에는 위와 같이 컴파일하면 된다.

<br>

<br>

### 쓰레드 동기화

쓰레드의 임계영역 때문에 생기는 문제점을 해결하기 위한 방법을 가리켜 `쓰레드 동기화(Synchronization)` 이라 한다.

<br>

#### 동기화의 두 가지 측면

쓰레드의 동기화는 쓰레드의 접근순서 때문에 발생하는 문제점의 해결책을 뜻한다. 그런데 동기화가 필요한 상황은 다음 두 가지 측면에서 생각해볼 수 있다.

* 동일한 메모리 영역으로의 동시접근이 발생하는 상황
* 동일한 메모리 영역에 접근하는 쓰레드의 실행순서를 지정해야 하는 상황

<br>

#### 뮤텍스(Mutex)

뮤텍스란 `Mutual Exclusion` 의 줄임 말로써 쓰레드의 동시접근을 허용하지 않는다는 의미가 있다. 그리고 그 이름처럼 뮤텍스는 쓰레드의 동시접근에 대한 해결책으로 주로 사용된다. 그럼 뮤텍스의 이해를 위해서는 간단하게 화장실을 생각하면 된다.

현실세계에서 임계영역은 화장실이다. 화장실에 둘 이상의 사람(쓰레드)이 동시에 들어갈 순 없다. 그리고 여기서 일어나는 모든 일들이 임계영역의 동기화에서 거의 그대로 표현된다. 다음은 화장실 사용의 일반적인 규칙이다.

1. 화장실의 접근보호를 위해서 들어갈 때 문을 잠그고 나올 때 문을 연다.
2. 화장실이 사용 중이라면, 밖에서 대기해야 한다.
3. 대기중인 사람이 둘 이상 될 수도 있고, 이들은 대기순서에 따라서 화장실에 들어간다.

위의 규칙은 화장실의 접근규칙이다. 마찬가지로 쓰레드도 임계영역의 보호를 위해서는 위의 규칙이 반영되어야 한다. 즉, 화장실에 들어갈 때 문을 잠그고, 나갈 때 문을 여는 자물쇠 시스템이 쓰레드의 동기화에 필요하다. 그리고 지금 설명하는 뮤텍스는 매우 훌륭한 자물쇠 시스템이다. 그럼 이어서 뮤텍스의 생성 및 소멸함수를 소개하겠다.

```c
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
> 성공 시 0, 실패 시 0 이외의 값 반환
```

* **mutex -** 뮤텍스 생성시에는 뮤텍스의 참조 값 저장을 위한 변수의 주소 값 전달, 그리고 뮤텍스 소멸 시에는 소멸하고자 하는 뮤텍스의 참조 값을 저장하고 있는 변수의 주소 값 전달.
* **attr -** 생성하는 뮤텍스의 특성정보를 담고 있는 변수의 주소 값 전달, 별도의 특성을 지정하지 않을 경우에는 NULL 전달.

위 함수들을 통해서도 확인할 수 있듯이, 자물쇠 시스템에 해당하는 뮤텍스의 생성을 위해서는 다음과 같이 pthread_mutex_t형 변수가 하나 선언되어야 한다.

**pthread_mutex_t mutex;**

뮤텍스 생성시 별도의 특성을 지정하지 않아서 두 번째 인자로 NULL을 전달하는 경우에는 매크로 **PTHREAD_MUTEX_INITIALIZR**을 이용해서 다음과 같이 초기화 하는 것도 가능하다.

**pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;**

하지만 가급적이면 pthread_mutex_init 함수를 이용한 초기화를 추천한다. 왜냐하면 매크로를 이용한 초기화는 오류발생에 대한 확인이 어렵기 때문이다. 그럼 이어서 뮤텍스를 이용해서 화장실에 비유되는 임계영역에 설치된 자물쇠를 걸어 잠그거나 풀 때 사용하는 함수를 소개하겠다.

```c
#include <pthread.h>

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
> 성공 시 0, 실패 시 0 이외의 값 반환
```

함수의 이름에도 lock, unlock이 있으니 쉽게 의미하는 바를 이해할 수 있다. 임계영역에 들어가기에 앞서 호출하는 함수가 pthread_mutex_lock 이다. 이 함수를 호출할 당시 다른 쓰레드가 이미 임계영역을 실행하고 있는 상황이라면, 이 쓰레드가 pthread_mutex_unlock 함수를 호출하면서 임계영역을 빠져나갈 때까지 pthread_mutex_lock 함수는 반환하지 않는다. 즉, 다른 쓰레드가 임계영역을 빠져나갈 때까지 블로킹 상태에 놓이게 된다. 그럼 이제 임계영역을 보호하기 위한 코드의 구성을 간단히 정리해 보겠다. 뮤텍스가 이미 생성된 상태에서는 다음의 형태로 임계영역을 보호하게 된다.

```c
pthread_mutex_lock(&mutex);
//임계영역의 시작
// .....
//임계영역의 끝
pthread_mutex_unlock(&mutex);
```

쉽게 말해서 lock, 그리고 unlock 함수를 이용해서 임계영역의 시작과 끝을 감싸는 것이다. 그러면 이것이 임계영역에 대한 자물쇠 역할을 하면서, 둘 이상의 쓰레드 접근을 허용하지 않게 된다. 

<br>

#### 세마포어(Semaphore)

이번에는 세마포어를 소개한다. 세마포어는 뮤텍스와 매우 유사하다. 따라서 뮤텍스에서 이해한 내용을 바탕으로 쉽게 세마포어를 이해할 수 있다. 참고로 여기서는 0과 1만을 사용하는 `바이너리 세마포어` 를 소개한다. 다음은 세마포어의 생성 및 소멸에 관한 함수이다.

```c
#include <semaphore.h>

int sem_init(sem_t *sem, int pshared, unsigned int value);
int sem_destroy(sem_t *sem);
> 성공 시 0, 실패 시 0 이외의 값 반환
```

* **sem -** 세마포어 생성시에는 세마포어의 참조 값 저장을 위한 변수의 주소 값 전달. 그리고 세마포어 소멸 시에는 소멸하고자 하는 세마포어의 참조 값을 저장하고 있는 변수의 주소 값 전달.
* **pshared -** 0이외의 값 전달 시, 둘 이상의 프로세스에 의해 접근 가능한 세마포어 생성, 0 전달시 하나의 프로세스 내에서만 접근 가능한 세마포어 생성
* **value -** 생성되는 세마포어의 초기 값 지정

위의 함수에서 매개변수 pshared는 우리의 관심영역 박이므로 0을 전달하면 된다. 그리고 매개변수 value에 의해 초기화되는 세마포어의 값이 무엇인지는 잠시 후 이해할 수 있다. 그럼 이어서 뮤텍스의 lock, unlock 함수에 해당하는 세마포어 관련 함수를 소개하겠다.

```c
#include <semaphore.h>

int sem_post(sem_t *sem);
int sem_wait(sem_t *sem);
> 성공 시 0, 실패 시 0 이외의 값 반환
```

* **sem -** 세마포어의 참조 값을 저장하고 있는 변수의 주소 값 전달, sem_post에 전달하면 세마포어의 값은 하나 증가, sem_wait에 전달되면 세마포어의 값은 하나 감소

sem_init 함수가 호출되면 운영체제에 의해서 세마포어 오브젝트라는 것이 만들어 지는데, 이곳에는 `세마포어 값(Semaphore Value)` 이라 불리는 정수가 하나 기록된다. 그리고 이 값은 sem_post 함수가 호출되면 1 증가하고, sem_wait 함수가 호출되면 1 감소한다. 단, 세마포어 값은 0보다 작아질 수 없기 때문에 현재 0인 상태에서 sem_wait 함수를 호출하면, 호출한 쓰레드는 함수가 반환되지 않아서 블로킹 상태에 놓이게 된다. 세마포어는 다음의 형태로 임계영역을 동기화시킬 수 있다. 

```c
sem_wait(&sem); // 세마포어 값을 0으로
// 임계영역의 시작
// .....
// 임계영역의 끝
sem_post(&sem); // 세마포어 값을 1로
```

위와 같이 코드를 구성하면, sem_wait 함수를 호출하면서 임계영역에 진입한 쓰레드가 sem_post 함수를 호출하기 전까지는 다른 쓰레드에 의해서 임계영역의 진입이 허용되지 않는다. 그리고 세마포어 값은 0과 1을 오가게 되는데, 이러한 특징 때문에 위와 같은 구성을 가리켜 `바이너리 세마포어`라 하는 것이다.