# Process Management

> 프로세스의 생성과 좀비 프로세스의 제거방법을 알아본다.

<br>

프로세스가 무엇인가에 대한 설명은 다른 포스팅에 작성해 두었으니 자세한 설명은 생략하고 일단은 프로세스가**"메모리 공간을 차지한 상태에서 실행중인 프로그램"** 이란것만 알아두자.

<br>

### fork 함수호출을 통한 프로세스의 생성

프로세스 생성에는 몇 가지 방법이 있다. 그러나 여기선 멀티프로세스 기반 서버 구현에 사용되는 fork 함수에 대해 설명하겠다.

```c
#include <unistd.h>

pid_t fork(void);
> 성공 시 프로세스 ID, 실패 시 -1 반환
```

fork 함수는 호출한 프로세스의 복사본을 생성한다. 즉, 전혀 새로운 다른 프로그램을 바탕으로 프로세스를 생성하는 것이 아니라 이미 실행중인, fork 함수를 호출한 프로세스를 복사하는 것이다. 그리고는 두 프로세스 모두 fork 함수의 호출 이후 문장을 실행하게 된다. 그런데 완전히 동일한 프로세스로, 메모리 영역까지 동일하게 복사하기 때문에 이후의 프로그램 흐르므은 fork 함수의 반환 값을 기준으로 나뉘도록 프로그래밍을 해야 한다. 즉, fork 함수의 다음 특징을 이용해서 프로그램의 흐름을 구분해야 한다.

* 부모 프로세스 - fork 함수의 반환 값은 자식 프로세스의 ID
* 자식 프로세스 - fork 함수의 반환 값은 0

여기서 '부모 프로세스(Parent Process)'란 원본 프로세스. 즉, fork 함수를 호출한 주체가 된다. 반면 '자식 프로세스(Child Process)'는 부모 프로세스의 fork 함수 호출을 통해서 복사된 프로세스를 의미한다.

<br>

<br>

### 프로세스 &#38; 좀비(Zombie) 프로세스

파일은 여는 것 못지않게 닫는 것이 중요하다. 마찬가지로 프로세스도 생성 못지않게 소멸이 중요하다. 만약에 프로세스를 대충 닫는다면 좀비 프로세스가 될지 모른다.

#### 좀비(Zombie) 프로세스

프로세스가 생성되고 나서 할 일을 다 하면(main 함수의 실행을 완료하면) 사라져야 하는데 사라지지 않고 좀비가 되어 시스템의 중요한 리소스를 차지하기도 한다. 이 상태에 있는 프로세스를 가리켜 `좀비 프로세스`라 하는데, 이는 시스템에 부담을 주는 원인이 되기도 한다.

<br>

#### 좀비 프로세스의 생성이유

좀비 프로세스의 생성을 막기에 앞서 좀비 프로세스의 생성 이유를 먼저 살펴보자. fork 함수의 호출로 생성된 자식 프로세스가 종료되는 상황 두 가지를 예로 들면 다음과 같다.

* 인자를 전달하면서 exit를 호출하는 경우
* main 함수에서 return 문을 실행하면서 값을 반환하는 경우

exit 함수로 전달되는 인자 값과 main 함수의 return 문에 의해 반환되는 값 모두 운영체제로 전달된다. 그리고 운영체제는 이 값이 자식 프로세스를 생성한 부모 프로세스에게 전달될 때까지 자식 프로세스를 소멸시키지 않는데, 바로 이 상황에 놓여있는 프로세스를 가리켜 좀비 프로세스라 한다. 

이 좀비 프로세스는 해당 자식 프로세스를 생성한 부모 프로세스에게 exit 함수의 인자 값이나 return 문의 반환값이 전달되어야 소멸한다. 그렇다면 어떻게 부모 프로세스에게 값을 전달할까? 부모 프로세스의 함수호출이 있어야 운영체제는 값을 전달해 준다. 이제부터 이 함수를 알아보도록 하자.

<br>

#### 좀비 프로세스의 소멸1: wait 함수의 사용

```c
#include <sys/wait.h>

pid_t wait(int *statloc);
> 성공 시 종료된 자식 프로세스의 ID, 실패 시 -1 반환
```

위 함수가 호출되었을 때, 이미 종료된 자식 프로세스가 있다면, 자식 프로세스가 종료되면서 전달한 값이 매개변수로 전달된 주소의 변수에 저장된다. 그런데 이 변수에 저장되는 값에는 자식 프로세스가 종료되면서 전달한 값 이외에도 다른 정보가 함께 포함되어 있으니, 다음 메크로 함수를 통해서 값의 분리 과정을 거쳐야 한다.

* **WIFEXITED -** 자식 프로세스가 정상 종료한 경우 '참(True)'을 반환한다.
* **WEXITSTATUS -** 자식 프로세스의 전달 값을 반환한다.

즉, wait 함수의 인자로 변수 status의 주소 값이 전달되었다면, wait 함수의 호출 이후에는 다음과 같은 유형의 코드를 구성해야 한다.

```c
if(WIFEXITED(status)){
	puts("Normal termination!");
	printf("Child pass num: %d", WEXITSTATUS(status));
}
```

이 wait 함수는 호출된 시점에서 종료된 자식 프로세스가 없다면, 임의의 자식 프로세스가 종료될 때까지 블로킹(Blocking) 상태에 놓인다는 특징이 있다. 때문에 함수의 호출에 주의해야 한다.

<br>

#### 좀비 프로세스의 소멸2: waitpid 함수의 사용

wait 함수의 블로킹이 문제가 된다면 waitpid 함수의 호출을 고려하면 된다. 이는 좀비 프로세스의 생성을 막는 두 번째 방법이자 블로킹 문제의 해결책이기도 하다.

```c
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statloc, int options);
> 성공 시 종료된 자식 프로세스의 ID(또는 0), 실패 시 -1 반환
```

* **pid -** 종료를 확인하고자 하는 자식 프로세스의 ID 전달, 이를 대신해서 -1을 전달하면 wait 함수와 마찬가지로 임의의 자식 프로세스가 종료되기를 기다린다.
* **statloc -** wait 함수의 매개변수 statloc과 동일한 의미로 사용된다.
* **options -** 헤더파일 sys/wait.h 에 선언된 정수 WNOHANG을 인자로 전달하면, 종료된 자식 프로세스가 존재하지 않아도 블로킹 상태에 있지 않고, 0을 반환하면서 함수를 빠져 나온다.

<br>

<br>

### 시그널 핸들링

지금까지 프로세스의 생성 및 소멸방법에 대해 살펴보았는데, 아직 해결하지 못한 문제가 하나 남아있다.

**"자식 프로세스가 언제 종료될 줄 알고 waitpid 함수를 계속 호출하고 있는 것인가?"**

대부분의 상황에서 부모 프로세스도 자식 프로세스 못지 않게 바쁘다. 따라서 자식 프로세스의 종료를 기다리면서 waitpid 함수만 호출할 수는 없는 노릇이다. 따라서 이번에는 이 문제의 해결책을 살펴도록 하겠다.

#### 운영체제의 호출

자섹 프로세스 종료의 인식주체는 운영체제이다. 따라서 운영체제가 열심히 일하고 있는 부모 프로세스에게 자식 프로세스의 종료를 알릴 수 있다면 효율적인 프로그램의 구현이 가능하다.

그리고 위의 상황에서 프로그램의 구현을 위해 `시그널 핸들링(signal handling)`이라는 것이 존재한다.  여기서 `시그널`은 특정상황이 발생했음을 알리기 위해 운영체제가 프로세스에게 전달하는 메시지를 의미한다. 그리고 그 메시지에 반응해서 메시지와 연관된, 미리 정의된 작업이 진행되는 것을 가리켜 `핸들링` 또는 `시그널 핸들링` 이라 한다.

<br>

#### 시그널과 signal 함수

다음은 시그널 핸들링의 이해를 돕기 위한 프로세스와 운영체제의 대화 내용이다. 이 대화 안에 시그널 핸들링과 관련된 내용 전부가 들어있다.

* **프로세스 -** 운영체제야! 내가 생성한 자식 프로세스가 종료되면 zombie_handler 라는 이름의 함수 좀 호출해 줘라
* **운영체제 -** 그래! 그럼 네가 생성한 자식 프로세스가 종료되면, 네가 말한 zombie_handler라는 이름의 함수를 내가 대신 호출해줄 테니, 그 상황에서 실행해야 할 문장들을 그 함수에 잘 묶어둬!

위의 대화 중에서 프로세스가 한 이야기가 `시그널 등록`에 해당한다. 즉, 프로세스는 자식 프로세스의 종료라는 상황 발생시, 특정 함수의 호출을 운영체제에게 요구하는 것이다. 이 요구는 다음 함수의 호출을 통해서 이뤄진다.

```c
#include <signal.h>

void (*signal(int signo, void (*func)(int)))(int);
> 시그널 발생시 호출되도록 이전에 등록된 함수의 포인터 반환
```

위 함수를 호출하면서 첫 번째 인자로 특정 상황에 대한 정보를, 두 번째 인자로 특정 상황에서 호출될 함수의 주소 값(포인터)을 전달한다. 그러면 첫 번째 인자를 통해 명시된 상황 발생시, 두 번째 인자로 전달된 주소 값의 함수가 호출된다. 참고로 signal 함수를 통해서 등록 가능한 특정 상황과 그 상황에 할당된 상수 몇몇을 정리하면 다음과 같다.

* **SIGALRM -** alram 함수호출을 통해서 등록된 시간이 된 상황
* **SIGINT -** Ctrl + C 가 입력된 상황
* **SIGCHLD -** 자식 프로세스가 종료된 상황

그럼 예를들어 다음 요청에 해당하는 signal 함수의 호출문장을 만들어 보겠다.

"자식 프로세스가 종료되면 mychild 함수를 호출해 달라"

이때 mychild 함수는 매개변수형이 int이고 반환형이 void여야 한다. 그래야 signal 함수의 두 번째 전달인자가 될 수 있다. 즉, signal 함수의 호출문장은 다음과 같이 구성하면 된다.

**signal(SIGCHLD, mychild);**

<br>

#### sigaction 함수를 이용한 시그널 핸들링

지금까지 설명한 내용만 가지고도 좀비 프로세스의 생성을 막는 코드를 충분히 만들어 낼 수 있다. 그러나 함수를 하나 더 소개하고자 한다. 이번에 소개할 sigaction함수는 signal 함수를 대체할 수 있고, signal 함수보다 훨씬 안정적으로 동작한다. 그 이유는 다음과 같다.

**"signal 함수는 유닉스 계열의 운영체제 별로 동작방식에 있어서 약간의 차이를 보일 수 있지만, sigaction 함수는 차이를 보이지 않는다."**

함수의 구조는 다음과 같다.

```c
#include <signal.h>

int sigaction(int signo, const struct sigaction *act, struct sigaction *oldact);
> 성공 시 0, 실패 시 -1 반환
```

* **signo -** signal 함수와 마찬가지로 시그널의 정보를 인자로 전달.
* **act -** 첫 번째 인자로 전달된 상수에 해당하는 시그널 발생시 호출될 함수(시그널 핸들러)의 정보 전달.
* **oldact -** 이전에 등록되었던 시그널 핸들러의 함수 포인터를 얻는데 사용되는 인자, 필요 없다면 0전달.

위 함수의 호출을 위해서는 sigaction 이라는 이름의 구조체 변수를 선언 및 초기화해야 하는데, 이 구조체는 다음과 같이 정의되어 있다.

```c
struct sigaction{
	void (*sa_handler)(int);
	sigset_t sa_mask;
	int sa_flag;
}
```

위의 구조체 멤버 중에서 sa_handler에 시그널 핸들러의 함수 포인터 값(주소 값)을 저장하면 된다. 그리고 sa_mask는 모든 비트를 0으로, sa_flag는 0으로 초기화한다. 이 두 멤버는 시그널 관련 옵션 및 특성의 지정에 사용되는데, 지금의 목적은 좀비 프로세스의 생성을 막는데 있으므로 이 두 멤버에 대한 설명은 생략하겠다.

sigaction 함수의 전체적인 사용 방법은 다음과 같다.

```c
struct sigaction act;
act.sa_handler = func;
sigemptyset(&act.sa_mask);
act.sa_flag = 0;
sigaction(SIGALRM, &act, 0);
```

sigempty 함수는 sa_mask의 모든 비트를 0으로 초기화 해주는데 사용된다.